// Generated by CoffeeScript 2.5.1
// node_modules/take-and-make/source/take-and-make.coffee
// Since this is typically the first bit of code included in our big compiled and
// concatenated JS files, this is a great place to demand strictness. CoffeeScript
// does not add strict on its own, but it will permit and enforce it.
"use strict";
var DebugTakeMake, Make, Take;

if (!((typeof Take !== "undefined" && Take !== null) || (typeof Make !== "undefined" && Make !== null))) {
  // We declare our globals such that they're visible everywhere within the current scope.
  // This allows for namespacing — all things within a given scope share a copy of Take & Make.
  Take = null;
  Make = null;
  DebugTakeMake = null;
  (function() {
    var addListener, allNeedsAreMet, alreadyChecking, alreadyWaitingToNotify, asynchronousResolve, checkWaitingTakers, clone, made, notify, notifyTakers, register, resolve, synchronousResolve, takersToNotify, timeoutsNeeded, timeoutsUsed, waitingTakers;
    made = {};
    waitingTakers = [];
    takersToNotify = [];
    alreadyWaitingToNotify = false;
    alreadyChecking = false;
    timeoutsNeeded = 0;
    timeoutsUsed = 0;
    Make = function(name, value = name) {
      if (name == null) {
        // Debug — call Make() in the console to see what we've regstered
        return clone(made);
      }
      // Synchronous register, returns value
      return register(name, value);
    };
    Take = function(needs, callback) {
      if (needs == null) {
        // Debug — call Take() in the console to see what we're waiting for
        return waitingTakers.slice();
      }
      // Synchronous and asynchronous resolve, returns value or object of values
      return resolve(needs, callback);
    };
    DebugTakeMake = function() {
      var base, i, j, len, len1, need, output, ref, waiting;
      output = {
        timeoutsNeeded: timeoutsNeeded,
        timeoutsUsed: timeoutsUsed,
        unresolved: {}
      };
      for (i = 0, len = waitingTakers.length; i < len; i++) {
        waiting = waitingTakers[i];
        ref = waiting.needs;
        for (j = 0, len1 = ref.length; j < len1; j++) {
          need = ref[j];
          if (made[need] == null) {
            if ((base = output.unresolved)[need] == null) {
              base[need] = 0;
            }
            output.unresolved[need]++;
          }
        }
      }
      return output;
    };
    register = function(name, value) {
      if (name === "") {
        throw new Error("You may not Make(\"\") an empty string.");
      }
      if (made[name] != null) {
        throw new Error(`You may not Make() the same name twice: ${name}`);
      }
      made[name] = value;
      checkWaitingTakers();
      return value;
    };
    checkWaitingTakers = function() {
      var i, index, len, taker;
      if (alreadyChecking) { // Prevent recursion from Make() calls inside notify()
        return;
      }
      alreadyChecking = true;
// Depends on `waitingTakers`
// Comments below are to help reason through the (potentially) recursive behaviour
      for (index = i = 0, len = waitingTakers.length; i < len; index = ++i) {
        taker = waitingTakers[index];
        if (allNeedsAreMet(taker.needs)) { // Depends on `made`
          waitingTakers.splice(index, 1); // Mutates `waitingTakers`
          notify(taker); // Calls to Make() or Take() will mutate `made` or `waitingTakers`
          alreadyChecking = false;
          return checkWaitingTakers(); // Restart: `waitingTakers` (and possibly `made`) were mutated
        }
      }
      return alreadyChecking = false;
    };
    allNeedsAreMet = function(needs) {
      return needs.every(function(name) {
        return made[name] != null;
      });
    };
    resolve = function(needs, callback) {
      if (callback != null) {
        // We always try to resolve both synchronously and asynchronously
        asynchronousResolve(needs, callback);
      }
      return synchronousResolve(needs);
    };
    asynchronousResolve = function(needs, callback) {
      var taker;
      if (needs === "") {
        needs = [];
      } else if (typeof needs === "string") {
        needs = [needs];
      }
      taker = {
        needs: needs,
        callback: callback
      };
      if (allNeedsAreMet(needs)) {
        takersToNotify.push(taker);
        timeoutsNeeded++;
        if (!alreadyWaitingToNotify) {
          alreadyWaitingToNotify = true;
          setTimeout(notifyTakers); // Preserve asynchrony
          return timeoutsUsed++;
        }
      } else {
        return waitingTakers.push(taker);
      }
    };
    synchronousResolve = function(needs) {
      var i, len, n, o;
      if (typeof needs === "string") {
        return made[needs];
      } else {
        o = {};
        for (i = 0, len = needs.length; i < len; i++) {
          n = needs[i];
          o[n] = made[n];
        }
        return o;
      }
    };
    notifyTakers = function() {
      var i, len, queue, taker;
      alreadyWaitingToNotify = false;
      queue = takersToNotify;
      takersToNotify = [];
      for (i = 0, len = queue.length; i < len; i++) {
        taker = queue[i];
        notify(taker);
      }
      return null;
    };
    notify = function(taker) {
      var resolvedNeeds;
      resolvedNeeds = taker.needs.map(function(name) {
        return made[name];
      });
      return taker.callback.apply(null, resolvedNeeds);
    };
    // IE11 doesn't support Object.assign({}, obj), so we just use our own
    clone = function(obj) {
      var k, out, v;
      out = {};
      for (k in obj) {
        v = obj[k];
        out[k] = v;
      }
      return out;
    };
    // We want to add a few handy one-time events.
    // However, we don't know if we'll be running in a browser, or in node.
    // Thus, we look for the presence of a "window" object as our clue.
    if (typeof window !== "undefined" && window !== null) {
      addListener = function(eventName) {
        var handler;
        return window.addEventListener(eventName, handler = function(eventObject) {
          window.removeEventListener(eventName, handler);
          Make(eventName, eventObject);
          return void 0; // prevent unload from opening a popup
        });
      };
      addListener("beforeunload");
      addListener("click");
      addListener("unload");
      // Since we have a window object, it's probably safe to assume we have a document object
      switch (document.readyState) {
        case "loading":
          addListener("DOMContentLoaded");
          addListener("load");
          break;
        case "interactive":
          Make("DOMContentLoaded");
          addListener("load");
          break;
        case "complete":
          Make("DOMContentLoaded");
          Make("load");
          break;
        default:
          throw new Error(`Unknown document.readyState: ${document.readyState}. Cannot setup Take&Make.`);
      }
    }
    // Finally, we're ready to hand over control to module systems
    if (typeof module !== "undefined" && module !== null) {
      return module.exports = {
        Take: Take,
        Make: Make,
        DebugTakeMake: DebugTakeMake
      };
    }
  })();
}

// node_modules/doom/doom.coffee
(function() {
  var DOOM, act, attrNames, eventNames, propNames, read, styleNames, svgElms, svgNS, write, xlinkNS;
  svgNS = "http://www.w3.org/2000/svg";
  xlinkNS = "http://www.w3.org/1999/xlink";
  // This is used to cache normalized keys, and to provide defaults for keys that shouldn't be normalized
  attrNames = {
    gradientUnits: "gradientUnits",
    preserveAspectRatio: "preserveAspectRatio",
    startOffset: "startOffset",
    viewBox: "viewBox"
  };
  // common case-sensitive attr names should be listed here as needed — see svg.cofee in https://github.com/cdig/svg for reference
  eventNames = {
    blur: true,
    change: true,
    click: true,
    focus: true,
    input: true,
    keydown: true,
    keypress: true,
    keyup: true,
    mousedown: true,
    mouseenter: true,
    mouseleave: true,
    mousemove: true,
    mouseup: true,
    scroll: true
  };
  propNames = {
    childNodes: true,
    firstChild: true,
    innerHTML: true,
    lastChild: true,
    nextSibling: true,
    parentElement: true,
    parentNode: true,
    previousSibling: true,
    textContent: true,
    value: true
  };
  styleNames = {
    animation: true,
    animationDelay: true,
    background: true,
    borderRadius: true,
    color: true,
    display: true,
    fontSize: "html", // Only treat as a style if this is an HTML elm. SVG elms will treat this as an attribute.
    fontFamily: true,
    fontWeight: true,
    height: "html",
    left: true,
    letterSpacing: true,
    lineHeight: true,
    maxHeight: true,
    maxWidth: true,
    margin: true,
    marginTop: true,
    marginLeft: true,
    marginRight: true,
    marginBottom: true,
    minWidth: true,
    minHeight: true,
    opacity: "html",
    overflow: true,
    overflowX: true,
    overflowY: true,
    padding: true,
    paddingTop: true,
    paddingLeft: true,
    paddingRight: true,
    paddingBottom: true,
    pointerEvents: true,
    position: true,
    textDecoration: true,
    top: true,
    transform: "html",
    transition: true,
    visibility: true,
    width: "html",
    zIndex: true
  };
  // When creating an element, SVG elements require a special namespace, so we use this list to know whether a tag name is for an SVG or not
  svgElms = {
    circle: true,
    clipPath: true,
    defs: true,
    g: true,
    image: true,
    mask: true,
    path: true,
    rect: true,
    svg: true,
    text: true,
    use: true
  };
  read = function(elm, k) {
    var base, base1, base2;
    if (propNames[k] != null) {
      return (base = elm._DOOM_prop)[k] != null ? base[k] : base[k] = elm[k];
    } else if (styleNames[k] != null) {
      return (base1 = elm._DOOM_style)[k] != null ? base1[k] : base1[k] = elm.style[k];
    } else {
      k = attrNames[k] != null ? attrNames[k] : attrNames[k] = k.replace(/([A-Z])/g, "-$1").toLowerCase(); // Normalize camelCase into kebab-case
      return (base2 = elm._DOOM_attr)[k] != null ? base2[k] : base2[k] = elm.getAttribute(k);
    }
  };
  write = function(elm, k, v) {
    var cache, isCached, ns;
    if (propNames[k] != null) {
      cache = elm._DOOM_prop;
      isCached = cache[k] === v;
      if (!isCached) {
        return elm[k] = cache[k] = v;
      }
    } else if ((styleNames[k] != null) && !(elm._DOOM_SVG && styleNames[k] === "html")) {
      cache = elm._DOOM_style;
      isCached = cache[k] === v;
      if (!isCached) {
        return elm.style[k] = cache[k] = v;
      }
    } else if (eventNames[k] != null) {
      cache = elm._DOOM_event;
      if (cache[k] === v) {
        return;
      }
      if (cache[k] != null) {
        throw "DOOM experimentally imposes a limit of one handler per event per object.";
      }
      // If we want to add multiple handlers for the same event to an object,
      // we need to decide how that interacts with passing null to remove events.
      // Should null remove all events? Probably. How do we track that? Keep an array of refs to handlers?
      // That seems slow and error prone.
      cache[k] = v;
      if (v != null) {
        return elm.addEventListener(k, v);
      } else {
        return elm.removeEventListener(k, v);
      }
    } else {
      cache = elm._DOOM_attr;
      if (cache[k] === v) {
        return;
      }
      cache[k] = v;
      ns = k === "xlink:href" ? xlinkNS : null; // Grab the namespace if needed
      k = attrNames[k] != null ? attrNames[k] : attrNames[k] = k.replace(/([A-Z])/g, "-$1").toLowerCase(); // Normalize camelCase into kebab-case
      if (ns != null) {
        if (v != null) {
          return elm.setAttributeNS(ns, k, v); // set DOM attribute
// v is explicitly set to null (not undefined)
        } else {
          return elm.removeAttributeNS(ns, k); // remove DOM attribute // check for null
        }
      } else {
        if (v != null) {
          return elm.setAttribute(k, v); // set DOM attribute
// v is explicitly set to null (not undefined)
        } else {
          return elm.removeAttribute(k); // remove DOM attribute // check for null
        }
      }
    }
  };
  act = function(elm, opts) {
    var k, v;
    // Initialize the caches
    if (elm._DOOM_attr == null) {
      elm._DOOM_attr = {};
    }
    if (elm._DOOM_prop == null) {
      elm._DOOM_prop = {};
    }
    if (elm._DOOM_style == null) {
      elm._DOOM_style = {};
    }
    if (typeof opts === "object") {
      for (k in opts) {
        v = opts[k];
        write(elm, k, v);
        null;
      }
      return elm;
    } else if (typeof opts === "string") {
      return read(elm, opts);
    }
  };
  // PUBLIC API ####################################################################################

  // The first arg can be an elm or array of elms
  // The second arg can be an object of stuff to update in the elm(s), in which case we'll return the elm(s).
  // Or it can be a string prop/attr/style to read from the elm(s), in which case we return the value(s).
  DOOM = function(elms, opts) {
    var elm, i, len, results;
    if (typeof elms !== "array") {
      elms = [elms];
    }
    for (i = 0, len = elms.length; i < len; i++) {
      elm = elms[i];
      ((function() {
        if (elm == null) {
          throw new Error("DOOM was called with a null element");
        }
      })());
    }
    if (opts == null) {
      throw new Error("DOOM was called with null options");
    }
    results = (function() {
      var j, len1, results1;
      results1 = [];
      for (j = 0, len1 = elms.length; j < len1; j++) {
        elm = elms[j];
        results1.push(act(elm, opts));
      }
      return results1;
    })();
    if (results.length === 1) {
      return results[0];
    } else {
      return results;
    }
  };
  DOOM.create = function(type, parent, opts) {
    var elm;
    if (svgElms[type] != null) {
      elm = document.createElementNS(svgNS, type);
      if (type === "svg") {
        (opts != null ? opts : opts = {}).xmlns = svgNS;
      } else {
        elm._DOOM_SVG = true;
      }
    } else {
      elm = document.createElement(type);
    }
    if (opts != null) {
      DOOM(elm, opts);
    }
    if (parent != null) {
      DOOM.append(parent, elm);
    }
    return elm;
  };
  DOOM.append = function(parent, child) {
    parent.appendChild(child);
    return child;
  };
  DOOM.prepend = function(parent, child) {
    if (parent.hasChildNodes()) {
      parent.insertBefore(child, parent.firstChild);
    } else {
      parent.appendChild(child);
    }
    return child;
  };
  DOOM.remove = function(elm, child) {
    if (child != null) {
      if (child.parentNode === elm) {
        elm.removeChild(child);
      }
      return child;
    } else {
      elm.remove();
      return elm;
    }
  };
  DOOM.empty = function(elm) {
    return elm.innerHTML = "";
  };
  if (this != null) {
    // Attach to this
    this.DOOM = DOOM;
  }
  if (typeof window !== "undefined" && window !== null) {
    // Attach to the window
    window.DOOM = DOOM;
  }
  if (Make != null) {
    // Integrate with Take & Make
    return Make("DOOM", DOOM);
  }
})();

// coffee/app.coffee
Take(["DOOM", "DOMContentLoaded"], function(DOOM) {
  var i, len, node, nodes, render, results1, root;
  nodes = [
    [
      "div",
      {},
      [
        [
          "h1",
          {
            textContent: "test"
          }
        ]
      ]
    ]
  ];
  root = document.querySelector("main");
  render = function(parent, [tag, attrs, children]) {
    var child, elm, i, len, results1;
    elm = DOOM.create(tag, parent, attrs);
    if (children != null ? children.length : void 0) {
      results1 = [];
      for (i = 0, len = children.length; i < len; i++) {
        child = children[i];
        results1.push(render(elm, child));
      }
      return results1;
    }
  };
  results1 = [];
  for (i = 0, len = nodes.length; i < len; i++) {
    node = nodes[i];
    DOOM.empty(root);
    results1.push(render(root, node));
  }
  return results1;
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBwLmpzIiwic291cmNlUm9vdCI6Ii4uIiwic291cmNlcyI6WyJidWlsZC9hcHAuY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFLb0U7Ozs7QUFDcEU7QUFEb0UsSUFBQSxhQUFBLEVBQUEsSUFBQSxFQUFBOztBQUlwRSxNQUFPLDhDQUFBLElBQVMsK0NBQWhCOzs7RUFJRSxJQUFBLEdBQU87RUFDUCxJQUFBLEdBQU87RUFDUCxhQUFBLEdBQWdCO0VBRWIsQ0FBQSxRQUFBLENBQUEsQ0FBQTtBQUVMLFFBQUEsV0FBQSxFQUFBLGNBQUEsRUFBQSxlQUFBLEVBQUEsc0JBQUEsRUFBQSxtQkFBQSxFQUFBLGtCQUFBLEVBQUEsS0FBQSxFQUFBLElBQUEsRUFBQSxNQUFBLEVBQUEsWUFBQSxFQUFBLFFBQUEsRUFBQSxPQUFBLEVBQUEsa0JBQUEsRUFBQSxjQUFBLEVBQUEsY0FBQSxFQUFBLFlBQUEsRUFBQTtJQUFJLElBQUEsR0FBTyxDQUFBO0lBQ1AsYUFBQSxHQUFnQjtJQUNoQixjQUFBLEdBQWlCO0lBQ2pCLHNCQUFBLEdBQXlCO0lBQ3pCLGVBQUEsR0FBa0I7SUFDbEIsY0FBQSxHQUFpQjtJQUNqQixZQUFBLEdBQWU7SUFFZixJQUFBLEdBQU8sUUFBQSxDQUFDLElBQUQsRUFBTyxRQUFRLElBQWYsQ0FBQTtNQUVMLElBQXlCLFlBQXpCOztBQUFBLGVBQU8sS0FBQSxDQUFNLElBQU4sRUFBUDtPQUROOzthQUlNLFFBQUEsQ0FBUyxJQUFULEVBQWUsS0FBZjtJQUxLO0lBUVAsSUFBQSxHQUFPLFFBQUEsQ0FBQyxLQUFELEVBQVEsUUFBUixDQUFBO01BRUwsSUFBb0MsYUFBcEM7O0FBQUEsZUFBTyxhQUFhLENBQUMsS0FBZCxDQUFBLEVBQVA7T0FETjs7YUFJTSxPQUFBLENBQVEsS0FBUixFQUFlLFFBQWY7SUFMSztJQVFQLGFBQUEsR0FBZ0IsUUFBQSxDQUFBLENBQUE7QUFDcEIsVUFBQSxJQUFBLEVBQUEsQ0FBQSxFQUFBLENBQUEsRUFBQSxHQUFB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QUFBLEVBQUEsS0FBQSxFQUFBLE1BQUEsRUFBQSxRQUFBLEVBQUE7RUFBRSxLQUFBLEdBQVE7SUFDTjtNQUFDLEtBQUQ7TUFBUSxDQUFBLENBQVI7TUFBWTtRQUNSO1VBQUMsSUFBRDtVQUFPO1lBQUMsV0FBQSxFQUFhO1VBQWQsQ0FBUDtTQURRO09BQVo7S0FETTs7RUFPUixJQUFBLEdBQU8sUUFBUSxDQUFDLGFBQVQsQ0FBdUIsTUFBdkI7RUFFUCxNQUFBLEdBQVMsUUFBQSxDQUFDLE1BQUQsRUFBUyxDQUFDLEdBQUQsRUFBTSxLQUFOLEVBQWEsUUFBYixDQUFULENBQUE7QUFDWCxRQUFBLEtBQUEsRUFBQSxHQUFBLEVBQUEsQ0FBQSxFQUFBLEdBQUEsRUFBQTtJQUFJLEdBQUEsR0FBTSxJQUFJLENBQUMsTUFBTCxDQUFZLEdBQVosRUFBaUIsTUFBakIsRUFBeUIsS0FBekI7SUFDTix1QkFBRyxRQUFRLENBQUUsZUFBYjtBQUNFO01BQUEsS0FBQSwwQ0FBQTs7c0JBQUEsTUFBQSxDQUFPLEdBQVAsRUFBWSxLQUFaO01BQUEsQ0FBQTtzQkFERjs7RUFGTztBQUtUO0VBQUEsS0FBQSx1Q0FBQTs7SUFDRSxJQUFJLENBQUMsS0FBTCxDQUFXLElBQVg7a0JBQ0EsTUFBQSxDQUFPLElBQVAsRUFBYSxJQUFiO0VBRkYsQ0FBQTs7QUFsQmlDLENBQW5DIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbiMgbm9kZV9tb2R1bGVzL3Rha2UtYW5kLW1ha2Uvc291cmNlL3Rha2UtYW5kLW1ha2UuY29mZmVlXG4jIFNpbmNlIHRoaXMgaXMgdHlwaWNhbGx5IHRoZSBmaXJzdCBiaXQgb2YgY29kZSBpbmNsdWRlZCBpbiBvdXIgYmlnIGNvbXBpbGVkIGFuZFxuIyBjb25jYXRlbmF0ZWQgSlMgZmlsZXMsIHRoaXMgaXMgYSBncmVhdCBwbGFjZSB0byBkZW1hbmQgc3RyaWN0bmVzcy4gQ29mZmVlU2NyaXB0XG4jIGRvZXMgbm90IGFkZCBzdHJpY3Qgb24gaXRzIG93biwgYnV0IGl0IHdpbGwgcGVybWl0IGFuZCBlbmZvcmNlIGl0LlxuXCJ1c2Ugc3RyaWN0XCI7XG5cbiMgQmFpbCBpZiBUYWtlJk1ha2UgaXMgYWxyZWFkeSBydW5uaW5nIGluIHRoaXMgc2NvcGUsIG9yIGlmIHNvbWV0aGluZyBlbHNlIGlzIHVzaW5nIG91ciBuYW1lc1xudW5sZXNzIFRha2U/IG9yIE1ha2U/XG5cbiAgIyBXZSBkZWNsYXJlIG91ciBnbG9iYWxzIHN1Y2ggdGhhdCB0aGV5J3JlIHZpc2libGUgZXZlcnl3aGVyZSB3aXRoaW4gdGhlIGN1cnJlbnQgc2NvcGUuXG4gICMgVGhpcyBhbGxvd3MgZm9yIG5hbWVzcGFjaW5nIOKAlCBhbGwgdGhpbmdzIHdpdGhpbiBhIGdpdmVuIHNjb3BlIHNoYXJlIGEgY29weSBvZiBUYWtlICYgTWFrZS5cbiAgVGFrZSA9IG51bGxcbiAgTWFrZSA9IG51bGxcbiAgRGVidWdUYWtlTWFrZSA9IG51bGxcblxuICBkbyAoKS0+XG5cbiAgICBtYWRlID0ge31cbiAgICB3YWl0aW5nVGFrZXJzID0gW11cbiAgICB0YWtlcnNUb05vdGlmeSA9IFtdXG4gICAgYWxyZWFkeVdhaXRpbmdUb05vdGlmeSA9IGZhbHNlXG4gICAgYWxyZWFkeUNoZWNraW5nID0gZmFsc2VcbiAgICB0aW1lb3V0c05lZWRlZCA9IDBcbiAgICB0aW1lb3V0c1VzZWQgPSAwXG5cbiAgICBNYWtlID0gKG5hbWUsIHZhbHVlID0gbmFtZSktPlxuICAgICAgIyBEZWJ1ZyDigJQgY2FsbCBNYWtlKCkgaW4gdGhlIGNvbnNvbGUgdG8gc2VlIHdoYXQgd2UndmUgcmVnc3RlcmVkXG4gICAgICByZXR1cm4gY2xvbmUgbWFkZSBpZiBub3QgbmFtZT9cblxuICAgICAgIyBTeW5jaHJvbm91cyByZWdpc3RlciwgcmV0dXJucyB2YWx1ZVxuICAgICAgcmVnaXN0ZXIgbmFtZSwgdmFsdWVcblxuXG4gICAgVGFrZSA9IChuZWVkcywgY2FsbGJhY2spLT5cbiAgICAgICMgRGVidWcg4oCUIGNhbGwgVGFrZSgpIGluIHRoZSBjb25zb2xlIHRvIHNlZSB3aGF0IHdlJ3JlIHdhaXRpbmcgZm9yXG4gICAgICByZXR1cm4gd2FpdGluZ1Rha2Vycy5zbGljZSgpIGlmIG5vdCBuZWVkcz9cblxuICAgICAgIyBTeW5jaHJvbm91cyBhbmQgYXN5bmNocm9ub3VzIHJlc29sdmUsIHJldHVybnMgdmFsdWUgb3Igb2JqZWN0IG9mIHZhbHVlc1xuICAgICAgcmVzb2x2ZSBuZWVkcywgY2FsbGJhY2tcblxuXG4gICAgRGVidWdUYWtlTWFrZSA9ICgpLT5cbiAgICAgIG91dHB1dCA9XG4gICAgICAgIHRpbWVvdXRzTmVlZGVkOiB0aW1lb3V0c05lZWRlZFxuICAgICAgICB0aW1lb3V0c1VzZWQ6IHRpbWVvdXRzVXNlZFxuICAgICAgICB1bnJlc29sdmVkOiB7fVxuICAgICAgZm9yIHdhaXRpbmcgaW4gd2FpdGluZ1Rha2Vyc1xuICAgICAgICBmb3IgbmVlZCBpbiB3YWl0aW5nLm5lZWRzXG4gICAgICAgICAgdW5sZXNzIG1hZGVbbmVlZF0/XG4gICAgICAgICAgICBvdXRwdXQudW5yZXNvbHZlZFtuZWVkXSA/PSAwXG4gICAgICAgICAgICBvdXRwdXQudW5yZXNvbHZlZFtuZWVkXSsrXG4gICAgICByZXR1cm4gb3V0cHV0XG5cblxuICAgIHJlZ2lzdGVyID0gKG5hbWUsIHZhbHVlKS0+XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbWF5IG5vdCBNYWtlKFxcXCJcXFwiKSBhbiBlbXB0eSBzdHJpbmcuXCIpIGlmIG5hbWUgaXMgXCJcIlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG1heSBub3QgTWFrZSgpIHRoZSBzYW1lIG5hbWUgdHdpY2U6ICN7bmFtZX1cIikgaWYgbWFkZVtuYW1lXT9cbiAgICAgIG1hZGVbbmFtZV0gPSB2YWx1ZVxuICAgICAgY2hlY2tXYWl0aW5nVGFrZXJzKClcbiAgICAgIHZhbHVlXG5cblxuICAgIGNoZWNrV2FpdGluZ1Rha2VycyA9ICgpLT5cbiAgICAgIHJldHVybiBpZiBhbHJlYWR5Q2hlY2tpbmcgIyBQcmV2ZW50IHJlY3Vyc2lvbiBmcm9tIE1ha2UoKSBjYWxscyBpbnNpZGUgbm90aWZ5KClcbiAgICAgIGFscmVhZHlDaGVja2luZyA9IHRydWVcblxuICAgICAgIyBDb21tZW50cyBiZWxvdyBhcmUgdG8gaGVscCByZWFzb24gdGhyb3VnaCB0aGUgKHBvdGVudGlhbGx5KSByZWN1cnNpdmUgYmVoYXZpb3VyXG5cbiAgICAgIGZvciB0YWtlciwgaW5kZXggaW4gd2FpdGluZ1Rha2VycyAjIERlcGVuZHMgb24gYHdhaXRpbmdUYWtlcnNgXG4gICAgICAgIGlmIGFsbE5lZWRzQXJlTWV0KHRha2VyLm5lZWRzKSAjIERlcGVuZHMgb24gYG1hZGVgXG4gICAgICAgICAgd2FpdGluZ1Rha2Vycy5zcGxpY2UoaW5kZXgsIDEpICMgTXV0YXRlcyBgd2FpdGluZ1Rha2Vyc2BcbiAgICAgICAgICBub3RpZnkodGFrZXIpICMgQ2FsbHMgdG8gTWFrZSgpIG9yIFRha2UoKSB3aWxsIG11dGF0ZSBgbWFkZWAgb3IgYHdhaXRpbmdUYWtlcnNgXG4gICAgICAgICAgYWxyZWFkeUNoZWNraW5nID0gZmFsc2VcbiAgICAgICAgICByZXR1cm4gY2hlY2tXYWl0aW5nVGFrZXJzKCkgIyBSZXN0YXJ0OiBgd2FpdGluZ1Rha2Vyc2AgKGFuZCBwb3NzaWJseSBgbWFkZWApIHdlcmUgbXV0YXRlZFxuXG4gICAgICBhbHJlYWR5Q2hlY2tpbmcgPSBmYWxzZVxuXG5cbiAgICBhbGxOZWVkc0FyZU1ldCA9IChuZWVkcyktPlxuICAgICAgcmV0dXJuIG5lZWRzLmV2ZXJ5IChuYW1lKS0+IG1hZGVbbmFtZV0/XG5cblxuICAgIHJlc29sdmUgPSAobmVlZHMsIGNhbGxiYWNrKS0+XG4gICAgICAjIFdlIGFsd2F5cyB0cnkgdG8gcmVzb2x2ZSBib3RoIHN5bmNocm9ub3VzbHkgYW5kIGFzeW5jaHJvbm91c2x5XG4gICAgICBhc3luY2hyb25vdXNSZXNvbHZlIG5lZWRzLCBjYWxsYmFjayBpZiBjYWxsYmFjaz9cbiAgICAgIHN5bmNocm9ub3VzUmVzb2x2ZSBuZWVkc1xuXG5cbiAgICBhc3luY2hyb25vdXNSZXNvbHZlID0gKG5lZWRzLCBjYWxsYmFjayktPlxuICAgICAgaWYgbmVlZHMgaXMgXCJcIlxuICAgICAgICBuZWVkcyA9IFtdXG4gICAgICBlbHNlIGlmIHR5cGVvZiBuZWVkcyBpcyBcInN0cmluZ1wiXG4gICAgICAgIG5lZWRzID0gW25lZWRzXVxuXG4gICAgICB0YWtlciA9IG5lZWRzOiBuZWVkcywgY2FsbGJhY2s6IGNhbGxiYWNrXG5cbiAgICAgIGlmIGFsbE5lZWRzQXJlTWV0IG5lZWRzXG4gICAgICAgIHRha2Vyc1RvTm90aWZ5LnB1c2ggdGFrZXJcbiAgICAgICAgdGltZW91dHNOZWVkZWQrK1xuICAgICAgICB1bmxlc3MgYWxyZWFkeVdhaXRpbmdUb05vdGlmeVxuICAgICAgICAgIGFscmVhZHlXYWl0aW5nVG9Ob3RpZnkgPSB0cnVlXG4gICAgICAgICAgc2V0VGltZW91dCBub3RpZnlUYWtlcnMgIyBQcmVzZXJ2ZSBhc3luY2hyb255XG4gICAgICAgICAgdGltZW91dHNVc2VkKytcbiAgICAgIGVsc2VcbiAgICAgICAgd2FpdGluZ1Rha2Vycy5wdXNoIHRha2VyXG5cblxuICAgIHN5bmNocm9ub3VzUmVzb2x2ZSA9IChuZWVkcyktPlxuICAgICAgaWYgdHlwZW9mIG5lZWRzIGlzIFwic3RyaW5nXCJcbiAgICAgICAgcmV0dXJuIG1hZGVbbmVlZHNdXG4gICAgICBlbHNlXG4gICAgICAgIG8gPSB7fVxuICAgICAgICBvW25dID0gbWFkZVtuXSBmb3IgbiBpbiBuZWVkc1xuICAgICAgICByZXR1cm4gb1xuXG5cbiAgICBub3RpZnlUYWtlcnMgPSAoKS0+XG4gICAgICBhbHJlYWR5V2FpdGluZ1RvTm90aWZ5ID0gZmFsc2VcbiAgICAgIHF1ZXVlID0gdGFrZXJzVG9Ob3RpZnlcbiAgICAgIHRha2Vyc1RvTm90aWZ5ID0gW11cbiAgICAgIG5vdGlmeSB0YWtlciBmb3IgdGFrZXIgaW4gcXVldWVcbiAgICAgIG51bGxcblxuXG4gICAgbm90aWZ5ID0gKHRha2VyKS0+XG4gICAgICByZXNvbHZlZE5lZWRzID0gdGFrZXIubmVlZHMubWFwIChuYW1lKS0+IG1hZGVbbmFtZV1cbiAgICAgIHRha2VyLmNhbGxiYWNrLmFwcGx5KG51bGwsIHJlc29sdmVkTmVlZHMpXG5cblxuICAgICMgSUUxMSBkb2Vzbid0IHN1cHBvcnQgT2JqZWN0LmFzc2lnbih7fSwgb2JqKSwgc28gd2UganVzdCB1c2Ugb3VyIG93blxuICAgIGNsb25lID0gKG9iaiktPlxuICAgICAgb3V0ID0ge31cbiAgICAgIG91dFtrXSA9IHYgZm9yIGssdiBvZiBvYmpcbiAgICAgIG91dFxuXG5cbiAgICAjIFdlIHdhbnQgdG8gYWRkIGEgZmV3IGhhbmR5IG9uZS10aW1lIGV2ZW50cy5cbiAgICAjIEhvd2V2ZXIsIHdlIGRvbid0IGtub3cgaWYgd2UnbGwgYmUgcnVubmluZyBpbiBhIGJyb3dzZXIsIG9yIGluIG5vZGUuXG4gICAgIyBUaHVzLCB3ZSBsb29rIGZvciB0aGUgcHJlc2VuY2Ugb2YgYSBcIndpbmRvd1wiIG9iamVjdCBhcyBvdXIgY2x1ZS5cbiAgICBpZiB3aW5kb3c/XG5cbiAgICAgIGFkZExpc3RlbmVyID0gKGV2ZW50TmFtZSktPlxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciBldmVudE5hbWUsIGhhbmRsZXIgPSAoZXZlbnRPYmplY3QpLT5cbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciBldmVudE5hbWUsIGhhbmRsZXJcbiAgICAgICAgICBNYWtlIGV2ZW50TmFtZSwgZXZlbnRPYmplY3RcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkICMgcHJldmVudCB1bmxvYWQgZnJvbSBvcGVuaW5nIGEgcG9wdXBcblxuICAgICAgYWRkTGlzdGVuZXIgXCJiZWZvcmV1bmxvYWRcIlxuICAgICAgYWRkTGlzdGVuZXIgXCJjbGlja1wiXG4gICAgICBhZGRMaXN0ZW5lciBcInVubG9hZFwiXG5cbiAgICAgICMgU2luY2Ugd2UgaGF2ZSBhIHdpbmRvdyBvYmplY3QsIGl0J3MgcHJvYmFibHkgc2FmZSB0byBhc3N1bWUgd2UgaGF2ZSBhIGRvY3VtZW50IG9iamVjdFxuICAgICAgc3dpdGNoIGRvY3VtZW50LnJlYWR5U3RhdGVcbiAgICAgICAgd2hlbiBcImxvYWRpbmdcIlxuICAgICAgICAgIGFkZExpc3RlbmVyIFwiRE9NQ29udGVudExvYWRlZFwiXG4gICAgICAgICAgYWRkTGlzdGVuZXIgXCJsb2FkXCJcbiAgICAgICAgd2hlbiBcImludGVyYWN0aXZlXCJcbiAgICAgICAgICBNYWtlIFwiRE9NQ29udGVudExvYWRlZFwiXG4gICAgICAgICAgYWRkTGlzdGVuZXIgXCJsb2FkXCJcbiAgICAgICAgd2hlbiBcImNvbXBsZXRlXCJcbiAgICAgICAgICBNYWtlIFwiRE9NQ29udGVudExvYWRlZFwiXG4gICAgICAgICAgTWFrZSBcImxvYWRcIlxuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yIFwiVW5rbm93biBkb2N1bWVudC5yZWFkeVN0YXRlOiAje2RvY3VtZW50LnJlYWR5U3RhdGV9LiBDYW5ub3Qgc2V0dXAgVGFrZSZNYWtlLlwiXG5cblxuICAgICMgRmluYWxseSwgd2UncmUgcmVhZHkgdG8gaGFuZCBvdmVyIGNvbnRyb2wgdG8gbW9kdWxlIHN5c3RlbXNcbiAgICBpZiBtb2R1bGU/XG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgVGFrZTogVGFrZSxcbiAgICAgICAgTWFrZTogTWFrZSxcbiAgICAgICAgRGVidWdUYWtlTWFrZTogRGVidWdUYWtlTWFrZVxuICAgICAgfVxuXG5cbiMgbm9kZV9tb2R1bGVzL2Rvb20vZG9vbS5jb2ZmZWVcbmRvICgpLT5cblxuICBzdmdOUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICB4bGlua05TID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCJcblxuICAjIFRoaXMgaXMgdXNlZCB0byBjYWNoZSBub3JtYWxpemVkIGtleXMsIGFuZCB0byBwcm92aWRlIGRlZmF1bHRzIGZvciBrZXlzIHRoYXQgc2hvdWxkbid0IGJlIG5vcm1hbGl6ZWRcbiAgYXR0ck5hbWVzID1cbiAgICBncmFkaWVudFVuaXRzOiBcImdyYWRpZW50VW5pdHNcIlxuICAgIHByZXNlcnZlQXNwZWN0UmF0aW86IFwicHJlc2VydmVBc3BlY3RSYXRpb1wiXG4gICAgc3RhcnRPZmZzZXQ6IFwic3RhcnRPZmZzZXRcIlxuICAgIHZpZXdCb3g6IFwidmlld0JveFwiXG4gICAgIyBjb21tb24gY2FzZS1zZW5zaXRpdmUgYXR0ciBuYW1lcyBzaG91bGQgYmUgbGlzdGVkIGhlcmUgYXMgbmVlZGVkIOKAlCBzZWUgc3ZnLmNvZmVlIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9jZGlnL3N2ZyBmb3IgcmVmZXJlbmNlXG5cbiAgZXZlbnROYW1lcyA9XG4gICAgYmx1cjogdHJ1ZVxuICAgIGNoYW5nZTogdHJ1ZVxuICAgIGNsaWNrOiB0cnVlXG4gICAgZm9jdXM6IHRydWVcbiAgICBpbnB1dDogdHJ1ZVxuICAgIGtleWRvd246IHRydWVcbiAgICBrZXlwcmVzczogdHJ1ZVxuICAgIGtleXVwOiB0cnVlXG4gICAgbW91c2Vkb3duOiB0cnVlXG4gICAgbW91c2VlbnRlcjogdHJ1ZVxuICAgIG1vdXNlbGVhdmU6IHRydWVcbiAgICBtb3VzZW1vdmU6IHRydWVcbiAgICBtb3VzZXVwOiB0cnVlXG4gICAgc2Nyb2xsOiB0cnVlXG5cbiAgcHJvcE5hbWVzID1cbiAgICBjaGlsZE5vZGVzOiB0cnVlXG4gICAgZmlyc3RDaGlsZDogdHJ1ZVxuICAgIGlubmVySFRNTDogdHJ1ZVxuICAgIGxhc3RDaGlsZDogdHJ1ZVxuICAgIG5leHRTaWJsaW5nOiB0cnVlXG4gICAgcGFyZW50RWxlbWVudDogdHJ1ZVxuICAgIHBhcmVudE5vZGU6IHRydWVcbiAgICBwcmV2aW91c1NpYmxpbmc6IHRydWVcbiAgICB0ZXh0Q29udGVudDogdHJ1ZVxuICAgIHZhbHVlOiB0cnVlXG5cbiAgc3R5bGVOYW1lcyA9XG4gICAgYW5pbWF0aW9uOiB0cnVlXG4gICAgYW5pbWF0aW9uRGVsYXk6IHRydWVcbiAgICBiYWNrZ3JvdW5kOiB0cnVlXG4gICAgYm9yZGVyUmFkaXVzOiB0cnVlXG4gICAgY29sb3I6IHRydWVcbiAgICBkaXNwbGF5OiB0cnVlXG4gICAgZm9udFNpemU6IFwiaHRtbFwiICMgT25seSB0cmVhdCBhcyBhIHN0eWxlIGlmIHRoaXMgaXMgYW4gSFRNTCBlbG0uIFNWRyBlbG1zIHdpbGwgdHJlYXQgdGhpcyBhcyBhbiBhdHRyaWJ1dGUuXG4gICAgZm9udEZhbWlseTogdHJ1ZVxuICAgIGZvbnRXZWlnaHQ6IHRydWVcbiAgICBoZWlnaHQ6IFwiaHRtbFwiXG4gICAgbGVmdDogdHJ1ZVxuICAgIGxldHRlclNwYWNpbmc6IHRydWVcbiAgICBsaW5lSGVpZ2h0OiB0cnVlXG4gICAgbWF4SGVpZ2h0OiB0cnVlXG4gICAgbWF4V2lkdGg6IHRydWVcbiAgICBtYXJnaW46IHRydWVcbiAgICBtYXJnaW5Ub3A6IHRydWVcbiAgICBtYXJnaW5MZWZ0OiB0cnVlXG4gICAgbWFyZ2luUmlnaHQ6IHRydWVcbiAgICBtYXJnaW5Cb3R0b206IHRydWVcbiAgICBtaW5XaWR0aDogdHJ1ZVxuICAgIG1pbkhlaWdodDogdHJ1ZVxuICAgIG9wYWNpdHk6IFwiaHRtbFwiXG4gICAgb3ZlcmZsb3c6IHRydWVcbiAgICBvdmVyZmxvd1g6IHRydWVcbiAgICBvdmVyZmxvd1k6IHRydWVcbiAgICBwYWRkaW5nOiB0cnVlXG4gICAgcGFkZGluZ1RvcDogdHJ1ZVxuICAgIHBhZGRpbmdMZWZ0OiB0cnVlXG4gICAgcGFkZGluZ1JpZ2h0OiB0cnVlXG4gICAgcGFkZGluZ0JvdHRvbTogdHJ1ZVxuICAgIHBvaW50ZXJFdmVudHM6IHRydWVcbiAgICBwb3NpdGlvbjogdHJ1ZVxuICAgIHRleHREZWNvcmF0aW9uOiB0cnVlXG4gICAgdG9wOiB0cnVlXG4gICAgdHJhbnNmb3JtOiBcImh0bWxcIlxuICAgIHRyYW5zaXRpb246IHRydWVcbiAgICB2aXNpYmlsaXR5OiB0cnVlXG4gICAgd2lkdGg6IFwiaHRtbFwiXG4gICAgekluZGV4OiB0cnVlXG5cbiAgIyBXaGVuIGNyZWF0aW5nIGFuIGVsZW1lbnQsIFNWRyBlbGVtZW50cyByZXF1aXJlIGEgc3BlY2lhbCBuYW1lc3BhY2UsIHNvIHdlIHVzZSB0aGlzIGxpc3QgdG8ga25vdyB3aGV0aGVyIGEgdGFnIG5hbWUgaXMgZm9yIGFuIFNWRyBvciBub3RcbiAgc3ZnRWxtcyA9XG4gICAgY2lyY2xlOiB0cnVlXG4gICAgY2xpcFBhdGg6IHRydWVcbiAgICBkZWZzOiB0cnVlXG4gICAgZzogdHJ1ZVxuICAgIGltYWdlOiB0cnVlXG4gICAgbWFzazogdHJ1ZVxuICAgIHBhdGg6IHRydWVcbiAgICByZWN0OiB0cnVlXG4gICAgc3ZnOiB0cnVlXG4gICAgdGV4dDogdHJ1ZVxuICAgIHVzZTogdHJ1ZVxuXG5cbiAgcmVhZCA9IChlbG0sIGspLT5cbiAgICBpZiBwcm9wTmFtZXNba10/XG4gICAgICBlbG0uX0RPT01fcHJvcFtrXSA/PSBlbG1ba11cbiAgICBlbHNlIGlmIHN0eWxlTmFtZXNba10/XG4gICAgICBlbG0uX0RPT01fc3R5bGVba10gPz0gZWxtLnN0eWxlW2tdXG4gICAgZWxzZVxuICAgICAgayA9IGF0dHJOYW1lc1trXSA/PSBrLnJlcGxhY2UoLyhbQS1aXSkvZyxcIi0kMVwiKS50b0xvd2VyQ2FzZSgpICMgTm9ybWFsaXplIGNhbWVsQ2FzZSBpbnRvIGtlYmFiLWNhc2VcbiAgICAgIGVsbS5fRE9PTV9hdHRyW2tdID89IGVsbS5nZXRBdHRyaWJ1dGUga1xuXG5cbiAgd3JpdGUgPSAoZWxtLCBrLCB2KS0+XG4gICAgaWYgcHJvcE5hbWVzW2tdP1xuICAgICAgY2FjaGUgPSBlbG0uX0RPT01fcHJvcFxuICAgICAgaXNDYWNoZWQgPSBjYWNoZVtrXSBpcyB2XG4gICAgICBlbG1ba10gPSBjYWNoZVtrXSA9IHYgaWYgbm90IGlzQ2FjaGVkXG4gICAgZWxzZSBpZiBzdHlsZU5hbWVzW2tdPyBhbmQgIShlbG0uX0RPT01fU1ZHIGFuZCBzdHlsZU5hbWVzW2tdIGlzIFwiaHRtbFwiKVxuICAgICAgY2FjaGUgPSBlbG0uX0RPT01fc3R5bGVcbiAgICAgIGlzQ2FjaGVkID0gY2FjaGVba10gaXMgdlxuICAgICAgZWxtLnN0eWxlW2tdID0gY2FjaGVba10gPSB2IGlmIG5vdCBpc0NhY2hlZFxuICAgIGVsc2UgaWYgZXZlbnROYW1lc1trXT9cbiAgICAgIGNhY2hlID0gZWxtLl9ET09NX2V2ZW50XG4gICAgICByZXR1cm4gaWYgY2FjaGVba10gaXMgdlxuICAgICAgaWYgY2FjaGVba10/XG4gICAgICAgIHRocm93IFwiRE9PTSBleHBlcmltZW50YWxseSBpbXBvc2VzIGEgbGltaXQgb2Ygb25lIGhhbmRsZXIgcGVyIGV2ZW50IHBlciBvYmplY3QuXCJcbiAgICAgICAgIyBJZiB3ZSB3YW50IHRvIGFkZCBtdWx0aXBsZSBoYW5kbGVycyBmb3IgdGhlIHNhbWUgZXZlbnQgdG8gYW4gb2JqZWN0LFxuICAgICAgICAjIHdlIG5lZWQgdG8gZGVjaWRlIGhvdyB0aGF0IGludGVyYWN0cyB3aXRoIHBhc3NpbmcgbnVsbCB0byByZW1vdmUgZXZlbnRzLlxuICAgICAgICAjIFNob3VsZCBudWxsIHJlbW92ZSBhbGwgZXZlbnRzPyBQcm9iYWJseS4gSG93IGRvIHdlIHRyYWNrIHRoYXQ/IEtlZXAgYW4gYXJyYXkgb2YgcmVmcyB0byBoYW5kbGVycz9cbiAgICAgICAgIyBUaGF0IHNlZW1zIHNsb3cgYW5kIGVycm9yIHByb25lLlxuICAgICAgY2FjaGVba10gPSB2XG4gICAgICBpZiB2P1xuICAgICAgICBlbG0uYWRkRXZlbnRMaXN0ZW5lciBrLCB2XG4gICAgICBlbHNlXG4gICAgICAgIGVsbS5yZW1vdmVFdmVudExpc3RlbmVyIGssIHZcbiAgICBlbHNlXG4gICAgICBjYWNoZSA9IGVsbS5fRE9PTV9hdHRyXG4gICAgICByZXR1cm4gaWYgY2FjaGVba10gaXMgdlxuICAgICAgY2FjaGVba10gPSB2XG4gICAgICBucyA9IGlmIGsgaXMgXCJ4bGluazpocmVmXCIgdGhlbiB4bGlua05TIGVsc2UgbnVsbCAjIEdyYWIgdGhlIG5hbWVzcGFjZSBpZiBuZWVkZWRcbiAgICAgIGsgPSBhdHRyTmFtZXNba10gPz0gay5yZXBsYWNlKC8oW0EtWl0pL2csXCItJDFcIikudG9Mb3dlckNhc2UoKSAjIE5vcm1hbGl6ZSBjYW1lbENhc2UgaW50byBrZWJhYi1jYXNlXG4gICAgICBpZiBucz9cbiAgICAgICAgaWYgdj8gIyBjaGVjayBmb3IgbnVsbFxuICAgICAgICAgIGVsbS5zZXRBdHRyaWJ1dGVOUyBucywgaywgdiAjIHNldCBET00gYXR0cmlidXRlXG4gICAgICAgIGVsc2UgIyB2IGlzIGV4cGxpY2l0bHkgc2V0IHRvIG51bGwgKG5vdCB1bmRlZmluZWQpXG4gICAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZU5TIG5zLCBrICMgcmVtb3ZlIERPTSBhdHRyaWJ1dGVcbiAgICAgIGVsc2VcbiAgICAgICAgaWYgdj8gIyBjaGVjayBmb3IgbnVsbFxuICAgICAgICAgIGVsbS5zZXRBdHRyaWJ1dGUgaywgdiAjIHNldCBET00gYXR0cmlidXRlXG4gICAgICAgIGVsc2UgIyB2IGlzIGV4cGxpY2l0bHkgc2V0IHRvIG51bGwgKG5vdCB1bmRlZmluZWQpXG4gICAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZSBrICMgcmVtb3ZlIERPTSBhdHRyaWJ1dGVcblxuXG4gIGFjdCA9IChlbG0sIG9wdHMpLT5cbiAgICAjIEluaXRpYWxpemUgdGhlIGNhY2hlc1xuICAgIGVsbS5fRE9PTV9hdHRyID89IHt9XG4gICAgZWxtLl9ET09NX3Byb3AgPz0ge31cbiAgICBlbG0uX0RPT01fc3R5bGUgPz0ge31cblxuICAgIGlmIHR5cGVvZiBvcHRzIGlzIFwib2JqZWN0XCJcbiAgICAgIGZvciBrLCB2IG9mIG9wdHNcbiAgICAgICAgd3JpdGUgZWxtLCBrLCB2XG4gICAgICAgIG51bGxcbiAgICAgIHJldHVybiBlbG1cbiAgICBlbHNlIGlmIHR5cGVvZiBvcHRzIGlzIFwic3RyaW5nXCJcbiAgICAgIHJldHVybiByZWFkIGVsbSwgb3B0c1xuXG5cbiAgIyBQVUJMSUMgQVBJICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4gICMgVGhlIGZpcnN0IGFyZyBjYW4gYmUgYW4gZWxtIG9yIGFycmF5IG9mIGVsbXNcbiAgIyBUaGUgc2Vjb25kIGFyZyBjYW4gYmUgYW4gb2JqZWN0IG9mIHN0dWZmIHRvIHVwZGF0ZSBpbiB0aGUgZWxtKHMpLCBpbiB3aGljaCBjYXNlIHdlJ2xsIHJldHVybiB0aGUgZWxtKHMpLlxuICAjIE9yIGl0IGNhbiBiZSBhIHN0cmluZyBwcm9wL2F0dHIvc3R5bGUgdG8gcmVhZCBmcm9tIHRoZSBlbG0ocyksIGluIHdoaWNoIGNhc2Ugd2UgcmV0dXJuIHRoZSB2YWx1ZShzKS5cbiAgRE9PTSA9IChlbG1zLCBvcHRzKS0+XG4gICAgZWxtcyA9IFtlbG1zXSB1bmxlc3MgdHlwZW9mIGVsbXMgaXMgXCJhcnJheVwiXG4gICAgKHRocm93IG5ldyBFcnJvciBcIkRPT00gd2FzIGNhbGxlZCB3aXRoIGEgbnVsbCBlbGVtZW50XCIgdW5sZXNzIGVsbT8pIGZvciBlbG0gaW4gZWxtc1xuICAgIHRocm93IG5ldyBFcnJvciBcIkRPT00gd2FzIGNhbGxlZCB3aXRoIG51bGwgb3B0aW9uc1wiIHVubGVzcyBvcHRzP1xuICAgIHJlc3VsdHMgPSAoYWN0IGVsbSwgb3B0cyBmb3IgZWxtIGluIGVsbXMpXG4gICAgcmV0dXJuIGlmIHJlc3VsdHMubGVuZ3RoIGlzIDEgdGhlbiByZXN1bHRzWzBdIGVsc2UgcmVzdWx0c1xuXG5cbiAgRE9PTS5jcmVhdGUgPSAodHlwZSwgcGFyZW50LCBvcHRzKS0+XG4gICAgaWYgc3ZnRWxtc1t0eXBlXT9cbiAgICAgIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyBzdmdOUywgdHlwZVxuICAgICAgaWYgdHlwZSBpcyBcInN2Z1wiXG4gICAgICAgIChvcHRzID89IHt9KS54bWxucyA9IHN2Z05TXG4gICAgICBlbHNlXG4gICAgICAgIGVsbS5fRE9PTV9TVkcgPSB0cnVlXG4gICAgZWxzZVxuICAgICAgZWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCB0eXBlXG4gICAgRE9PTSBlbG0sIG9wdHMgaWYgb3B0cz9cbiAgICBET09NLmFwcGVuZCBwYXJlbnQsIGVsbSBpZiBwYXJlbnQ/XG4gICAgcmV0dXJuIGVsbVxuXG5cbiAgRE9PTS5hcHBlbmQgPSAocGFyZW50LCBjaGlsZCktPlxuICAgIHBhcmVudC5hcHBlbmRDaGlsZCBjaGlsZFxuICAgIHJldHVybiBjaGlsZFxuXG5cbiAgRE9PTS5wcmVwZW5kID0gKHBhcmVudCwgY2hpbGQpLT5cbiAgICBpZiBwYXJlbnQuaGFzQ2hpbGROb2RlcygpXG4gICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlIGNoaWxkLCBwYXJlbnQuZmlyc3RDaGlsZFxuICAgIGVsc2VcbiAgICAgIHBhcmVudC5hcHBlbmRDaGlsZCBjaGlsZFxuICAgIHJldHVybiBjaGlsZFxuXG5cbiAgRE9PTS5yZW1vdmUgPSAoZWxtLCBjaGlsZCktPlxuICAgIGlmIGNoaWxkP1xuICAgICAgZWxtLnJlbW92ZUNoaWxkIGNoaWxkIGlmIGNoaWxkLnBhcmVudE5vZGUgaXMgZWxtXG4gICAgICByZXR1cm4gY2hpbGRcbiAgICBlbHNlXG4gICAgICBlbG0ucmVtb3ZlKClcbiAgICAgIHJldHVybiBlbG1cblxuXG4gIERPT00uZW1wdHkgPSAoZWxtKS0+XG4gICAgZWxtLmlubmVySFRNTCA9IFwiXCJcblxuXG4gICMgQXR0YWNoIHRvIHRoaXNcbiAgQERPT00gPSBET09NIGlmIEA/XG5cbiAgIyBBdHRhY2ggdG8gdGhlIHdpbmRvd1xuICB3aW5kb3cuRE9PTSA9IERPT00gaWYgd2luZG93P1xuXG4gICMgSW50ZWdyYXRlIHdpdGggVGFrZSAmIE1ha2VcbiAgTWFrZSBcIkRPT01cIiwgRE9PTSBpZiBNYWtlP1xuXG5cbiMgY29mZmVlL2FwcC5jb2ZmZWVcblRha2UgW1wiRE9PTVwiLCBcIkRPTUNvbnRlbnRMb2FkZWRcIl0sIChET09NKS0+XG5cblxuXG4gIG5vZGVzID0gW1xuICAgIFtcImRpdlwiLCB7fSwgW1xuICAgICAgICBbXCJoMVwiLCB7dGV4dENvbnRlbnQ6IFwidGVzdFwifV1cbiAgICAgIF1cbiAgICBdXG4gIF1cblxuICByb290ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvciBcIm1haW5cIlxuXG4gIHJlbmRlciA9IChwYXJlbnQsIFt0YWcsIGF0dHJzLCBjaGlsZHJlbl0pLT5cbiAgICBlbG0gPSBET09NLmNyZWF0ZSB0YWcsIHBhcmVudCwgYXR0cnNcbiAgICBpZiBjaGlsZHJlbj8ubGVuZ3RoXG4gICAgICByZW5kZXIgZWxtLCBjaGlsZCBmb3IgY2hpbGQgaW4gY2hpbGRyZW5cblxuICBmb3Igbm9kZSBpbiBub2Rlc1xuICAgIERPT00uZW1wdHkgcm9vdFxuICAgIHJlbmRlciByb290LCBub2RlXG4iXX0=
//# sourceURL=/Users/admin/Work/whistle/build/app.coffee